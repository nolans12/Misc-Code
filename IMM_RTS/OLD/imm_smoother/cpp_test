class IMMSmootherRTS
{
public:
    IMMSmootherRTS(const MatrixXd& PI_, double eps_ = 1e-12)
        : PI(PI_), eps(eps_) {}

    struct Result
    {
        std::vector<VectorXd> x_common;
        std::vector<MatrixXd> P_common;
        MatrixXd mu_s;
        std::vector<std::vector<VectorXd>> x_mode;
        std::vector<std::vector<MatrixXd>> P_mode;
    };

    Result smooth(const IMM& imm)
    {
        const auto& hist = imm.history();
        const int K = static_cast<int>(hist.size());
        const int M = static_cast<int>(imm.models.size());
        const int cd = imm.common_dim;

        // Storage
        std::vector<std::vector<VectorXd>> x_mode(K, std::vector<VectorXd>(M));
        std::vector<std::vector<MatrixXd>> P_mode(K, std::vector<MatrixXd>(M));
        MatrixXd mu_s = MatrixXd::Zero(K, M);

        std::vector<VectorXd> x_common(K, VectorXd::Zero(cd));
        std::vector<MatrixXd> P_common(K, MatrixXd::Zero(cd, cd));

        // ======================================================
        // Initialize at final time
        // ======================================================
        mu_s.row(K - 1) = hist[K - 1].mu.transpose();

        for (int j = 0; j < M; ++j)
        {
            x_mode[K - 1][j] = hist[K - 1].models[j].x_filt;
            P_mode[K - 1][j] = hist[K - 1].models[j].P_filt;
        }

        momentMatch(imm, x_mode[K - 1], P_mode[K - 1],
                    mu_s.row(K - 1).transpose(),
                    x_common[K - 1], P_common[K - 1]);

        // ======================================================
        // Backward recursion
        // ======================================================
        for (int k = K - 2; k >= 0; --k)
        {
            VectorXd mu_f = hist[k].mu;
            VectorXd mu_next = mu_s.row(k + 1).transpose();

            // ---------- backward transition probs ----------
            VectorXd c = PI.transpose() * mu_f;
            c = c.array().max(eps);

            MatrixXd b = MatrixXd::Zero(M, M);
            for (int i = 0; i < M; ++i)
                for (int j = 0; j < M; ++j)
                    b(i, j) = PI(j, i) * mu_f(j) / c(i);

            // ---------- backward mixing ----------
            VectorXd d = b.transpose() * mu_next;
            d = d.array().max(eps);

            MatrixXd mu_mix = MatrixXd::Zero(M, M);
            for (int j = 0; j < M; ++j)
                for (int i = 0; i < M; ++i)
                    mu_mix(i, j) = b(i, j) * mu_next(i) / d(j);

            // ---------- mix smoothed states (COMMON space) ----------
            std::vector<VectorXd> x0(M, VectorXd::Zero(cd));
            std::vector<MatrixXd> P0(M, MatrixXd::Zero(cd, cd));

            for (int j = 0; j < M; ++j)
            {
                for (int i = 0; i < M; ++i)
                {
                    VectorXd xi;
                    MatrixXd Pi;
                    imm.models[i]->toCommon(x_mode[k + 1][i],
                                            P_mode[k + 1][i],
                                            xi, Pi);
                    x0[j] += mu_mix(i, j) * xi;
                }

                for (int i = 0; i < M; ++i)
                {
                    VectorXd xi;
                    MatrixXd Pi;
                    imm.models[i]->toCommon(x_mode[k + 1][i],
                                            P_mode[k + 1][i],
                                            xi, Pi);
                    VectorXd dx = xi - x0[j];
                    P0[j] += mu_mix(i, j) * (Pi + dx * dx.transpose());
                }
            }

            // ---------- RTS per model (INTERNAL space) ----------
            for (int j = 0; j < M; ++j)
            {
                const auto& snap = hist[k].models[j];
                const auto& snap_p = hist[k + 1].models[j];

                VectorXd x0_j;
                MatrixXd P0_j;
                imm.models[j]->toInternal(x0[j], P0[j], x0_j, P0_j);

                MatrixXd P_pred_inv =
                    snap_p.P_pred.completeOrthogonalDecomposition().pseudoInverse();

                MatrixXd A = snap.P_filt * snap_p.F.transpose() * P_pred_inv;

                VectorXd x_s = snap.x_filt + A * (x0_j - snap_p.x_pred);
                MatrixXd P_s = snap.P_filt - A * (P0_j - snap_p.P_pred) * A.transpose();

                x_mode[k][j] = x_s;
                P_mode[k][j] = sym(P_s);
            }

            // ---------- smoothed mode probabilities ----------
            VectorXd Lambda = VectorXd::Zero(M);

            for (int j = 0; j < M; ++j)
            {
                double val = 0.0;

                VectorXd x_pred_c;
                MatrixXd P_pred_c;
                imm.models[j]->toCommon(hist[k + 1].models[j].x_pred,
                                        hist[k + 1].models[j].P_pred,
                                        x_pred_c, P_pred_c);

                for (int i = 0; i < M; ++i)
                {
                    VectorXd xi_c;
                    MatrixXd Pi_c;
                    imm.models[i]->toCommon(x_mode[k + 1][i],
                                            P_mode[k + 1][i],
                                            xi_c, Pi_c);

                    val += PI(j, i) *
                           gaussianPDF(xi_c - x_pred_c, P_pred_c);
                }
                Lambda(j) = std::max(val, eps);
            }

            VectorXd mu_tmp = Lambda.array() * mu_f.array();
            mu_s.row(k) = (mu_tmp / mu_tmp.sum()).transpose();

            // ---------- moment match ----------
            momentMatch(imm, x_mode[k], P_mode[k],
                        mu_s.row(k).transpose(),
                        x_common[k], P_common[k]);
        }

        return {x_common, P_common, mu_s, x_mode, P_mode};
    }

private:
    MatrixXd PI;
    double eps;

    void momentMatch(const IMM& imm,
                     const std::vector<VectorXd>& x_modes,
                     const std::vector<MatrixXd>& P_modes,
                     const VectorXd& mu,
                     VectorXd& x,
                     MatrixXd& P) const
    {
        const int cd = imm.common_dim;
        x = VectorXd::Zero(cd);
        P = MatrixXd::Zero(cd, cd);

        for (int j = 0; j < mu.size(); ++j)
        {
            VectorXd xj;
            MatrixXd Pj;
            imm.models[j]->toCommon(x_modes[j], P_modes[j], xj, Pj);
            x += mu(j) * xj;
        }

        for (int j = 0; j < mu.size(); ++j)
        {
            VectorXd xj;
            MatrixXd Pj;
            imm.models[j]->toCommon(x_modes[j], P_modes[j], xj, Pj);
            VectorXd dx = xj - x;
            P += mu(j) * (Pj + dx * dx.transpose());
        }

        P = sym(P);
    }
};
